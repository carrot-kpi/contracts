{"language":"Solidity","sources":{"contracts/kpi-tokens-managers/KPITokensManager1.sol":{"content":"pragma solidity 0.8.19;\n\nimport {Ownable} from \"oz/access/Ownable.sol\";\nimport {Clones} from \"oz/proxy/Clones.sol\";\nimport {IKPIToken} from \"../interfaces/kpi-tokens/IKPIToken.sol\";\nimport {BaseTemplatesManager} from \"../BaseTemplatesManager.sol\";\nimport {Template} from \"../interfaces/IBaseTemplatesManager.sol\";\nimport {IKPITokensManager1} from \"../interfaces/kpi-tokens-managers/IKPITokensManager1.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens manager\n/// @dev The KPI token manager contract acts as a template\n/// registry for KPI token implementations. Additionally, templates\n/// can also only be instantiated by the manager itself,\n/// exclusively by request of the factory contract. All\n/// templates-related functions are governance-gated\n/// (addition, removal, upgrade of templates and more) and the\n/// governance contract must be the owner of the KPI tokens manager.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ncontract KPITokensManager1 is BaseTemplatesManager, IKPITokensManager1 {\n    constructor(address _factory) BaseTemplatesManager(_factory) {}\n\n    /// @dev Calculates the salt value used in CREATE2 when\n    /// instantiating new templates. the salt is calculated as\n    /// keccak256(abi.encodePacked(`_description`, `_initializationData`, `_oraclesInitializationData`)).\n    /// @param _description An IPFS cid pointing to a structured JSON describing what the KPI token is about.\n    /// @param _initializationData The template-specific ABI-encoded initialization data.\n    /// @param _oraclesInitializationData The initialization data required by the template to initialize\n    /// the linked oracles.\n    /// @return The salt value.\n    function salt(\n        address _creator,\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _creator,\n                    _id,\n                    _description,\n                    _expiration,\n                    _initializationData,\n                    _oraclesInitializationData\n                )\n            );\n    }\n\n    /// @dev Predicts a KPI token template instance address based on the input data.\n    /// @param _id The id of the template that is to be instantiated.\n    /// @param _description An IPFS cid pointing to a structured JSON describing what the KPI token is about.\n    /// @param _initializationData The template-specific ABI-encoded initialization data.\n    /// @param _oraclesInitializationData The initialization data required by the template to initialize\n    /// the linked oracles.\n    /// @return The address at which the template with the given input\n    /// parameters will be instantiated.\n    function predictInstanceAddress(\n        address _creator,\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external view override returns (address) {\n        return\n            Clones.predictDeterministicAddress(\n                latestVersionStorageTemplate(_id).addrezz,\n                salt(\n                    _creator,\n                    _id,\n                    _description,\n                    _expiration,\n                    _initializationData,\n                    _oraclesInitializationData\n                )\n            );\n    }\n\n    /// @dev Instantiates a given template using EIP 1167 minimal proxies.\n    /// The input data will both be used to choose the instantiated template\n    /// and to feed it initialization data.\n    /// @param _templateId The id of the template that is to be instantiated.\n    /// @param _description An IPFS cid pointing to a structured JSON describing what the KPI token is about.\n    /// @param _initializationData The template-specific ABI-encoded initialization data.\n    /// @param _oraclesInitializationData The initialization data required by the template to initialize\n    /// the linked oracles.\n    /// @return The address at which the template with the given input\n    /// parameters has been instantiated.\n    function instantiate(\n        address _creator,\n        uint256 _templateId,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external override returns (address, uint128) {\n        if (msg.sender != factory) revert Forbidden();\n        Template memory _template = latestVersionStorageTemplate(_templateId);\n        address _instance = Clones.cloneDeterministic(\n            _template.addrezz,\n            salt(\n                _creator,\n                _templateId,\n                _description,\n                _expiration,\n                _initializationData,\n                _oraclesInitializationData\n            )\n        );\n        return (_instance, _template.version);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"contracts/interfaces/kpi-tokens/IKPIToken.sol":{"content":"pragma solidity >=0.8.0;\n\nimport {InitializeKPITokenParams} from \"../../commons/Types.sol\";\nimport {IKPITokensManager1} from \"../kpi-tokens-managers/IKPITokensManager1.sol\";\nimport {Template} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI token interface\n/// @dev KPI token interface.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPIToken {\n    function initialize(InitializeKPITokenParams memory _params)\n        external\n        payable;\n\n    function finalize(uint256 _result) external;\n\n    function redeem(bytes memory _data) external;\n\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n\n    function template() external view returns (Template memory);\n\n    function description() external view returns (string memory);\n\n    function finalized() external view returns (bool);\n\n    function expiration() external view returns (uint256);\n\n    function creationTimestamp() external view returns (uint256);\n\n    function data() external view returns (bytes memory);\n\n    function oracles() external view returns (address[] memory);\n}\n"},"contracts/BaseTemplatesManager.sol":{"content":"pragma solidity 0.8.19;\n\nimport {Ownable} from \"oz/access/Ownable.sol\";\nimport {Clones} from \"oz/proxy/Clones.sol\";\nimport {IKPIToken} from \"./interfaces/kpi-tokens/IKPIToken.sol\";\nimport {IOracle} from \"./interfaces/oracles/IOracle.sol\";\nimport {IBaseTemplatesManager, Template} from \"./interfaces/IBaseTemplatesManager.sol\";\nimport {IKPITokensFactory} from \"./interfaces/IKPITokensFactory.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Templates manager\n/// @dev The templates manager contract acts as a template\n/// registry for oracles/kpi token implementations. Additionally,\n/// templates can also only be instantiated by the manager itself,\n/// (exclusively by request of either the factory, in case of KPI\n/// tokens, or a KPI token being created in case of oracles). All\n/// template-related functions are governance-gated\n/// (addition, removal, upgrade of templates and more) and the\n/// governance contract must be the owner of the templates manager.\n/// The contract will keep track of all the versions of every template\n/// and will keep history of even deleted/unactive templates.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\nabstract contract BaseTemplatesManager is Ownable, IBaseTemplatesManager {\n    address public factory;\n    uint256 internal templateId;\n    Template[] internal latestVersionTemplates;\n    mapping(uint256 => uint256) internal templateIdToLatestVersionIndex;\n    mapping(uint256 => mapping(uint128 => Template))\n        internal templateByIdAndVersion;\n\n    error NonExistentTemplate();\n    error ZeroAddressFactory();\n    error Forbidden();\n    error ZeroAddressTemplate();\n    error InvalidSpecification();\n    error NoKeyForTemplate();\n    error InvalidVersionBump();\n    error InvalidIndices();\n    error AutomationNotSupported();\n\n    event AddTemplate(\n        uint256 indexed id,\n        address indexed template,\n        string specification\n    );\n    event RemoveTemplate(uint256 indexed id);\n    event UpgradeTemplate(\n        uint256 indexed id,\n        address indexed newTemplate,\n        uint256 newVersion,\n        string newSpecification\n    );\n    event UpdateTemplateSpecification(\n        uint256 indexed id,\n        string newSpecification,\n        uint256 version\n    );\n\n    constructor(address _factory) {\n        if (_factory == address(0)) revert ZeroAddressFactory();\n        factory = _factory;\n    }\n\n    /// @dev Adds a template to the registry. This function can only be called\n    /// by the contract owner (governance).\n    /// @param _template The template's address.\n    /// @param _specification An IPFS cid pointing to a structured JSON\n    /// describing the template.\n    function addTemplate(address _template, string calldata _specification)\n        external\n        override\n        onlyOwner\n    {\n        if (_template == address(0)) revert ZeroAddressTemplate();\n        if (bytes(_specification).length == 0) revert InvalidSpecification();\n        uint256 _id = ++templateId;\n        Template memory _templateStruct = Template({\n            id: _id,\n            addrezz: _template,\n            version: 1,\n            specification: _specification\n        });\n        latestVersionTemplates.push(_templateStruct);\n        templateIdToLatestVersionIndex[_id] = latestVersionTemplates.length;\n\n        // save an immutable copy of the template at this initial version for\n        // historical reasons\n        templateByIdAndVersion[_id][1] = _templateStruct;\n        emit AddTemplate(_id, _template, _specification);\n    }\n\n    /// @dev Removes a template from the registry. This function can only be called\n    /// by the contract owner (governance).\n    /// @param _id The id of the template that must be removed.\n    function removeTemplate(uint256 _id) external override onlyOwner {\n        uint256 _index = templateIdToLatestVersionIndex[_id];\n        if (_index == 0) revert NonExistentTemplate();\n        Template storage _lastLatestVersionTemplate = latestVersionTemplates[\n            latestVersionTemplates.length - 1\n        ];\n        if (_lastLatestVersionTemplate.id != _id) {\n            latestVersionTemplates[_index - 1] = _lastLatestVersionTemplate;\n            templateIdToLatestVersionIndex[\n                _lastLatestVersionTemplate.id\n            ] = _index;\n        }\n        delete templateIdToLatestVersionIndex[_id];\n        latestVersionTemplates.pop();\n        emit RemoveTemplate(_id);\n    }\n\n    /// @dev Updates a template's latest version's specification. The specification\n    /// is a cid pointing to a structured JSON file containing data about the template.\n    /// This function can only be called by the contract owner (governance).\n    /// @param _id The template's id.\n    /// @param _newSpecification the updated specification for the template with id `_id`.\n    function updateTemplateSpecification(\n        uint256 _id,\n        string calldata _newSpecification\n    ) external override onlyOwner {\n        if (bytes(_newSpecification).length == 0) revert InvalidSpecification();\n        uint128 _version = latestVersionStorageTemplate(_id).version;\n        _updateTemplateSpecification(_id, _version, _newSpecification);\n        emit UpdateTemplateSpecification(_id, _newSpecification, _version);\n    }\n\n    /// @dev Updates a template specification. The specification is a cid\n    /// pointing to a structured JSON file containing data about the template.\n    /// This function can only be called by the contract owner (governance).\n    /// @param _id The template's id.\n    /// @param _version The version of the template we want to update.\n    /// @param _newSpecification the updated specification for the template with id `_id`.\n    function updateTemplateSpecification(\n        uint256 _id,\n        uint128 _version,\n        string calldata _newSpecification\n    ) external override onlyOwner {\n        if (bytes(_newSpecification).length == 0) revert InvalidSpecification();\n        _updateTemplateSpecification(_id, _version, _newSpecification);\n        emit UpdateTemplateSpecification(_id, _newSpecification, _version);\n    }\n\n    /// @dev Internal implementation of the specification update function. It checks if the\n    /// updated version is the latest one, and in case it is it updates the `latestVersionTemplates`\n    /// array in addition to the `templateByIdAndVersion` one.\n    /// @param _id The template's id.\n    /// @param _version The version of the template we want to update.\n    /// @param _newSpecification the updated specification for the template with id `_id`.\n    function _updateTemplateSpecification(\n        uint256 _id,\n        uint128 _version,\n        string calldata _newSpecification\n    ) internal {\n        Template\n            storage _latestVersionStorageTemplate = latestVersionStorageTemplate(\n                _id\n            );\n        Template storage _templateByIdAndVersion = templateByIdAndVersion[_id][\n            _version\n        ];\n        if (_templateByIdAndVersion.addrezz == address(0))\n            revert NonExistentTemplate();\n        if (_version == _latestVersionStorageTemplate.version)\n            _latestVersionStorageTemplate.specification = _newSpecification;\n        _templateByIdAndVersion.specification = _newSpecification;\n    }\n\n    /// @dev Upgrades a template. This function can only be called by the contract owner (governance).\n    /// @param _id The id of the template that needs to be upgraded.\n    /// @param _newTemplate The new address of the template.\n    /// @param _newSpecification The updated specification for the upgraded template.\n    function upgradeTemplate(\n        uint256 _id,\n        address _newTemplate,\n        string calldata _newSpecification\n    ) external override onlyOwner {\n        if (_newTemplate == address(0)) revert ZeroAddressTemplate();\n        if (bytes(_newSpecification).length == 0) revert InvalidSpecification();\n        Template\n            storage _latestVersionTemplateFromStorage = latestVersionStorageTemplate(\n                _id\n            );\n        if (\n            keccak256(bytes(_latestVersionTemplateFromStorage.specification)) ==\n            keccak256(bytes(_newSpecification))\n        ) revert InvalidSpecification();\n        _latestVersionTemplateFromStorage.addrezz = _newTemplate;\n        _latestVersionTemplateFromStorage.specification = _newSpecification;\n        uint128 _updatedVersion = _latestVersionTemplateFromStorage.version + 1;\n        _latestVersionTemplateFromStorage.version = _updatedVersion;\n\n        templateByIdAndVersion[_id][_updatedVersion] = Template({\n            id: _id,\n            addrezz: _newTemplate,\n            specification: _newSpecification,\n            version: _updatedVersion\n        });\n        emit UpgradeTemplate(\n            _id,\n            _newTemplate,\n            _updatedVersion,\n            _newSpecification\n        );\n    }\n\n    /// @dev Gets a template from storage, in its latest, most up\n    /// to date version.\n    /// @param _id The id of the template that needs to be fetched.\n    /// @return The template from storage with id `_id` in its most\n    /// up to date version.\n    function latestVersionStorageTemplate(uint256 _id)\n        internal\n        view\n        returns (Template storage)\n    {\n        if (_id == 0) revert NonExistentTemplate();\n        uint256 _index = templateIdToLatestVersionIndex[_id];\n        if (_index == 0) revert NonExistentTemplate();\n        Template storage _template = latestVersionTemplates[_index - 1];\n        return _template;\n    }\n\n    /// @dev Gets a template by id. This only works on latest-version\n    /// templates, so the latest version of the template with id `_id`\n    /// will be returned. To check out old versions use\n    /// `template(uint256 _id, uint128 _version)`.\n    /// @param _id The id of the template that needs to be fetched.\n    /// @return The template with id `_id`, at its latest, most up to\n    /// date version.\n    function template(uint256 _id)\n        external\n        view\n        override\n        returns (Template memory)\n    {\n        return latestVersionStorageTemplate(_id);\n    }\n\n    /// @dev Gets a template by id and version. Can be used to fetch\n    /// old version templates to maximize transparency.\n    /// @param _id The id of the template that needs to be fetched.\n    /// @param _version The version at which the template should be fetched.\n    /// @return The template with id `_id` at version `_version`.\n    function template(uint256 _id, uint128 _version)\n        external\n        view\n        override\n        returns (Template memory)\n    {\n        if (_id == 0) revert NonExistentTemplate();\n        Template memory _template = templateByIdAndVersion[_id][_version];\n        if (_template.addrezz == address(0)) revert NonExistentTemplate();\n        return _template;\n    }\n\n    /// @dev Used to determine whether a template with a certain id exists\n    /// or not. This function checks existance on the latest version of each\n    /// template. I.e. if a template existed in the past and got deleted, this\n    /// will return false.\n    /// @param _id The id of the template that needs to be checked.\n    /// @return True if the template exists, false otherwise.\n    function exists(uint256 _id) external view override returns (bool) {\n        if (_id == 0) return false;\n        uint256 _index = templateIdToLatestVersionIndex[_id];\n        if (_index == 0) return false;\n        return latestVersionTemplates[_index - 1].id == _id;\n    }\n\n    /// @dev Gets the amount of all registered templates (works on the latest\n    // versions template array and doesn't take into account deleted templates).\n    /// @return The templates amount.\n    function templatesAmount() external view override returns (uint256) {\n        return latestVersionTemplates.length;\n    }\n\n    /// @dev Gets the next template id, i.e. the id of the next template that will\n    /// be added to the manager.\n    /// @return The next template id.\n    function nextTemplateId() external view override returns (uint256) {\n        return templateId + 1;\n    }\n\n    /// @dev Gets a templates slice off of the latest version templates array based\n    /// on indexes. N.B.: the templates are not ordered and due to how templates are\n    /// removed, it could happen to have 2 disjointed slices with the same template\n    /// being in both, even though it should be rare.\n    /// @param _fromIndex The index from which to get templates (inclusive).\n    /// @param _toIndex The maximum index to which to get templates (the element at this index won't be included).\n    /// @return A templates array representing the slice taken through the given indexes.\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        override\n        returns (Template[] memory)\n    {\n        if (_toIndex > latestVersionTemplates.length || _fromIndex > _toIndex)\n            revert InvalidIndices();\n        uint256 _range = _toIndex - _fromIndex;\n        Template[] memory _templates = new Template[](_range);\n        for (uint256 _i = 0; _i < _range; _i++)\n            _templates[_i] = latestVersionTemplates[_fromIndex + _i];\n        return _templates;\n    }\n}\n"},"contracts/interfaces/IBaseTemplatesManager.sol":{"content":"pragma solidity >=0.8.0;\n\nstruct Template {\n    address addrezz;\n    uint128 version;\n    uint256 id;\n    string specification;\n}\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Base templates manager interface\n/// @dev Interface for the base templates manager contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IBaseTemplatesManager {\n    function addTemplate(address _template, string calldata _specification)\n        external;\n\n    function removeTemplate(uint256 _id) external;\n\n    function upgradeTemplate(\n        uint256 _id,\n        address _newTemplate,\n        string calldata _newSpecification\n    ) external;\n\n    function updateTemplateSpecification(\n        uint256 _id,\n        string calldata _newSpecification\n    ) external;\n\n    function updateTemplateSpecification(\n        uint256 _id,\n        uint128 _version,\n        string calldata _newSpecification\n    ) external;\n\n    function template(uint256 _id) external view returns (Template memory);\n\n    function template(uint256 _id, uint128 _version)\n        external\n        view\n        returns (Template memory);\n\n    function exists(uint256 _id) external view returns (bool);\n\n    function templatesAmount() external view returns (uint256);\n\n    function nextTemplateId() external view returns (uint256);\n\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        returns (Template[] memory);\n}\n"},"contracts/interfaces/kpi-tokens-managers/IKPITokensManager1.sol":{"content":"pragma solidity >=0.8.0;\n\nimport {IBaseTemplatesManager} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens manager interface\n/// @dev Interface for the KPI tokens manager contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPITokensManager1 is IBaseTemplatesManager {\n    function predictInstanceAddress(\n        address _creator,\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external view returns (address);\n\n    function instantiate(\n        address _creator,\n        uint256 _templateId,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external returns (address, uint128);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"contracts/commons/Types.sol":{"content":"pragma solidity >=0.8.0;\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Types\n/// @dev General collection of reusable types.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\n\nstruct TokenAmount {\n    address token;\n    uint256 amount;\n}\n\nstruct InitializeKPITokenParams {\n    address creator;\n    address oraclesManager;\n    address kpiTokensManager;\n    address feeReceiver;\n    uint256 kpiTokenTemplateId;\n    uint128 kpiTokenTemplateVersion;\n    string description;\n    uint256 expiration;\n    bytes kpiTokenData;\n    bytes oraclesData;\n}\n\nstruct InitializeOracleParams {\n    address creator;\n    address kpiToken;\n    uint256 templateId;\n    uint128 templateVersion;\n    bytes data;\n}\n"},"contracts/interfaces/oracles/IOracle.sol":{"content":"pragma solidity >=0.8.0;\n\nimport {IOraclesManager1} from \"../oracles-managers/IOraclesManager1.sol\";\nimport {InitializeOracleParams} from \"../../commons/Types.sol\";\nimport {Template} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Oracle interface\n/// @dev Oracle interface.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IOracle {\n    function initialize(InitializeOracleParams memory _params) external payable;\n\n    function kpiToken() external returns (address);\n\n    function template() external view returns (Template memory);\n\n    function finalized() external view returns (bool);\n\n    function data() external view returns (bytes memory);\n}\n"},"contracts/interfaces/IKPITokensFactory.sol":{"content":"pragma solidity >=0.8.0;\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens factory interface\n/// @dev Interface for the KPI tokens factory contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPITokensFactory {\n    function createToken(\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external payable returns (address);\n\n    function allowOraclesCreation(address _address) external returns (bool);\n\n    function kpiTokensManager() external returns (address);\n\n    function oraclesManager() external returns (address);\n\n    function feeReceiver() external returns (address);\n\n    function setKpiTokensManager(address _kpiTokensManager) external;\n\n    function setOraclesManager(address _oraclesManager) external;\n\n    function setFeeReceiver(address _feeReceiver) external;\n\n    function kpiTokensAmount() external view returns (uint256);\n\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        returns (address[] memory);\n}\n"},"contracts/interfaces/oracles-managers/IOraclesManager1.sol":{"content":"pragma solidity >=0.8.0;\n\nimport {IBaseTemplatesManager} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Oracles manager interface\n/// @dev Interface for the oracles manager contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IOraclesManager1 is IBaseTemplatesManager {\n    function predictInstanceAddress(\n        address _creator,\n        uint256 _id,\n        bytes memory _initializationData\n    ) external view returns (address);\n\n    function instantiate(\n        address _creator,\n        uint256 _id,\n        bytes memory _initializationData\n    ) external payable returns (address);\n}\n"}},"settings":{"remappings":["ds-test/=lib/ds-test/src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","oz-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","oz/=lib/openzeppelin-contracts/contracts/","tests/=tests/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
