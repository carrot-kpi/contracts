{
    "language": "Solidity",
    "sources": {
        "contracts/KPITokensFactory.sol": {
            "content": "pragma solidity 0.8.19;\n\nimport {Ownable} from \"oz/access/Ownable.sol\";\nimport {IKPITokensFactory} from \"./interfaces/IKPITokensFactory.sol\";\nimport {IKPITokensManager1} from \"./interfaces/kpi-tokens-managers/IKPITokensManager1.sol\";\nimport {IKPIToken} from \"./interfaces/kpi-tokens/IKPIToken.sol\";\nimport {InitializeKPITokenParams} from \"./commons/Types.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens factory\n/// @dev The factory contract acts as an entry point for users wanting to\n/// create a KPI token., passing as input the id of the template that is\n/// to be used, alongside the description's IPFS cid (pointing to a\n/// structured JSON describing what the KPI token is about) and the oracles\n/// initialization data (template-specific). Other utility view functions\n/// are included to query the storage of the contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ncontract KPITokensFactory is Ownable, IKPITokensFactory {\n    address public kpiTokensManager;\n    address public oraclesManager;\n    address public feeReceiver;\n    mapping(address => bool) public allowOraclesCreation;\n    address[] internal kpiTokens;\n\n    error ZeroAddressKpiTokensManager();\n    error ZeroAddressOraclesManager();\n    error ZeroAddressFeeReceiver();\n    error InvalidIndices();\n\n    event CreateToken(address token);\n    event SetKpiTokensManager(address kpiTokensManager);\n    event SetOraclesManager(address oraclesManager);\n    event SetFeeReceiver(address feeReceiver);\n\n    constructor(\n        address _kpiTokensManager,\n        address _oraclesManager,\n        address _feeReceiver\n    ) {\n        if (_kpiTokensManager == address(0))\n            revert ZeroAddressKpiTokensManager();\n        if (_oraclesManager == address(0)) revert ZeroAddressOraclesManager();\n        if (_feeReceiver == address(0)) revert ZeroAddressFeeReceiver();\n\n        kpiTokensManager = _kpiTokensManager;\n        oraclesManager = _oraclesManager;\n        feeReceiver = _feeReceiver;\n    }\n\n    /// @dev Creates a KPI token with the input data.\n    /// @param _id The id of the KPI token template to be used.\n    /// @param _description An IPFS cid pointing to a structured JSON describing what the KPI token is about.\n    /// @param _expiration A timestamp indicating the KPI token's expiration (avoids locked funds in case\n    /// something happens to an oracle).\n    /// @param _initializationData The template-specific ABI-encoded initialization data.\n    /// @param _oraclesInitializationData The initialization data required by the template to initialize\n    /// the linked oracles.\n    function createToken(\n        uint256 _id,\n        string calldata _description,\n        uint256 _expiration,\n        bytes calldata _initializationData,\n        bytes calldata _oraclesInitializationData\n    ) external payable override returns (address) {\n        (address _instance, uint128 _templateVersion) = IKPITokensManager1(\n            kpiTokensManager\n        ).instantiate(\n                msg.sender,\n                _id,\n                _description,\n                _expiration,\n                _initializationData,\n                _oraclesInitializationData\n            );\n        allowOraclesCreation[_instance] = true;\n        IKPIToken(_instance).initialize{value: msg.value}(\n            InitializeKPITokenParams({\n                creator: msg.sender,\n                oraclesManager: oraclesManager,\n                kpiTokensManager: kpiTokensManager,\n                feeReceiver: feeReceiver,\n                kpiTokenTemplateId: _id,\n                kpiTokenTemplateVersion: _templateVersion,\n                description: _description,\n                expiration: _expiration,\n                kpiTokenData: _initializationData,\n                oraclesData: _oraclesInitializationData\n            })\n        );\n        allowOraclesCreation[_instance] = false;\n        kpiTokens.push(_instance);\n\n        emit CreateToken(_instance);\n\n        return _instance;\n    }\n\n    /// @dev KPI tokens manager address setter. Can only be called by the contract owner.\n    /// @param _kpiTokensManager The new KPI tokens manager address.\n    function setKpiTokensManager(address _kpiTokensManager)\n        external\n        override\n        onlyOwner\n    {\n        if (_kpiTokensManager == address(0))\n            revert ZeroAddressKpiTokensManager();\n        kpiTokensManager = _kpiTokensManager;\n        emit SetKpiTokensManager(_kpiTokensManager);\n    }\n\n    /// @dev Oracles manager address setter. Can only be called by the contract owner.\n    /// @param _oraclesManager The new oracles manager address.\n    function setOraclesManager(address _oraclesManager)\n        external\n        override\n        onlyOwner\n    {\n        if (_oraclesManager == address(0)) revert ZeroAddressOraclesManager();\n        oraclesManager = _oraclesManager;\n        emit SetOraclesManager(_oraclesManager);\n    }\n\n    /// @dev Fee receiver address setter. Can only be called by the contract owner.\n    /// @param _feeReceiver The new fee receiver address.\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        if (_feeReceiver == address(0)) revert ZeroAddressFeeReceiver();\n        feeReceiver = _feeReceiver;\n        emit SetFeeReceiver(_feeReceiver);\n    }\n\n    /// @dev Gets the amount of all created KPI tokens.\n    /// @return The KPI tokens amount.\n    function kpiTokensAmount() external view override returns (uint256) {\n        return kpiTokens.length;\n    }\n\n    /// @dev Gets a KPI tokens slice based on indexes.\n    /// @param _fromIndex The index from which to get KPI tokens (inclusive).\n    /// @param _toIndex The maximum index to which to get KPI tokens (the element\n    /// at this index won't be included).\n    /// @return An address array representing the slice taken between the given indexes.\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        if (_toIndex > kpiTokens.length || _fromIndex > _toIndex)\n            revert InvalidIndices();\n        uint256 _range = _toIndex - _fromIndex;\n        address[] memory _kpiTokens = new address[](_range);\n        for (uint256 _i = 0; _i < _range; _i++)\n            _kpiTokens[_i] = kpiTokens[_fromIndex + _i];\n        return _kpiTokens;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "contracts/interfaces/IKPITokensFactory.sol": {
            "content": "pragma solidity >=0.8.0;\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens factory interface\n/// @dev Interface for the KPI tokens factory contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPITokensFactory {\n    function createToken(\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external payable returns (address);\n\n    function allowOraclesCreation(address _address) external returns (bool);\n\n    function kpiTokensManager() external returns (address);\n\n    function oraclesManager() external returns (address);\n\n    function feeReceiver() external returns (address);\n\n    function setKpiTokensManager(address _kpiTokensManager) external;\n\n    function setOraclesManager(address _oraclesManager) external;\n\n    function setFeeReceiver(address _feeReceiver) external;\n\n    function kpiTokensAmount() external view returns (uint256);\n\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        returns (address[] memory);\n}\n"
        },
        "contracts/interfaces/kpi-tokens-managers/IKPITokensManager1.sol": {
            "content": "pragma solidity >=0.8.0;\n\nimport {IBaseTemplatesManager} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI tokens manager interface\n/// @dev Interface for the KPI tokens manager contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPITokensManager1 is IBaseTemplatesManager {\n    function predictInstanceAddress(\n        address _creator,\n        uint256 _id,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external view returns (address);\n\n    function instantiate(\n        address _creator,\n        uint256 _templateId,\n        string memory _description,\n        uint256 _expiration,\n        bytes memory _initializationData,\n        bytes memory _oraclesInitializationData\n    ) external returns (address, uint128);\n}\n"
        },
        "contracts/interfaces/kpi-tokens/IKPIToken.sol": {
            "content": "pragma solidity >=0.8.0;\n\nimport {InitializeKPITokenParams} from \"../../commons/Types.sol\";\nimport {IKPITokensManager1} from \"../kpi-tokens-managers/IKPITokensManager1.sol\";\nimport {Template} from \"../IBaseTemplatesManager.sol\";\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title KPI token interface\n/// @dev KPI token interface.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IKPIToken {\n    function initialize(InitializeKPITokenParams memory _params)\n        external\n        payable;\n\n    function finalize(uint256 _result) external;\n\n    function redeem(bytes memory _data) external;\n\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n\n    function template() external view returns (Template memory);\n\n    function description() external view returns (string memory);\n\n    function finalized() external view returns (bool);\n\n    function expiration() external view returns (uint256);\n\n    function creationTimestamp() external view returns (uint256);\n\n    function data() external view returns (bytes memory);\n\n    function oracles() external view returns (address[] memory);\n}\n"
        },
        "contracts/commons/Types.sol": {
            "content": "pragma solidity >=0.8.0;\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Types\n/// @dev General collection of reusable types.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\n\nstruct TokenAmount {\n    address token;\n    uint256 amount;\n}\n\nstruct InitializeKPITokenParams {\n    address creator;\n    address oraclesManager;\n    address kpiTokensManager;\n    address feeReceiver;\n    uint256 kpiTokenTemplateId;\n    uint128 kpiTokenTemplateVersion;\n    string description;\n    uint256 expiration;\n    bytes kpiTokenData;\n    bytes oraclesData;\n}\n\nstruct InitializeOracleParams {\n    address creator;\n    address kpiToken;\n    uint256 templateId;\n    uint128 templateVersion;\n    bytes data;\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
        },
        "contracts/interfaces/IBaseTemplatesManager.sol": {
            "content": "pragma solidity >=0.8.0;\n\nstruct Template {\n    address addrezz;\n    uint128 version;\n    uint256 id;\n    string specification;\n}\n\n/// SPDX-License-Identifier: GPL-3.0-or-later\n/// @title Base templates manager interface\n/// @dev Interface for the base templates manager contract.\n/// @author Federico Luzzi - <federico.luzzi@protonmail.com>\ninterface IBaseTemplatesManager {\n    function addTemplate(address _template, string calldata _specification)\n        external;\n\n    function removeTemplate(uint256 _id) external;\n\n    function upgradeTemplate(\n        uint256 _id,\n        address _newTemplate,\n        string calldata _newSpecification\n    ) external;\n\n    function updateTemplateSpecification(\n        uint256 _id,\n        string calldata _newSpecification\n    ) external;\n\n    function updateTemplateSpecification(\n        uint256 _id,\n        uint128 _version,\n        string calldata _newSpecification\n    ) external;\n\n    function template(uint256 _id) external view returns (Template memory);\n\n    function template(uint256 _id, uint128 _version)\n        external\n        view\n        returns (Template memory);\n\n    function exists(uint256 _id) external view returns (bool);\n\n    function templatesAmount() external view returns (uint256);\n\n    function nextTemplateId() external view returns (uint256);\n\n    function enumerate(uint256 _fromIndex, uint256 _toIndex)\n        external\n        view\n        returns (Template[] memory);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "ds-test/=lib/ds-test/src/",
            "forge-std/=lib/forge-std/src/",
            "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts/",
            "oz-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
            "oz/=lib/openzeppelin-contracts/contracts/",
            "tests/=tests/"
        ],
        "optimizer": { "enabled": true, "runs": 1000000 },
        "metadata": { "bytecodeHash": "ipfs", "appendCBOR": true },
        "outputSelection": {
            "*": {
                "": ["ast"],
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "paris",
        "viaIR": true,
        "libraries": {}
    }
}
